Оценка сложности алгоритмов важна для понимания того, насколько быстро или медленно алгоритм будет работать при
обработке разного объема данных. Величина, используемая для оценки сложности, называется временной сложностью, и она
измеряется в терминах числа базовых операций (сравнений, присваиваний и др.), которые алгоритм выполняет в зависимости
от размера входных данных.

Существует два основных способа оценки временной сложности:

1. **Символьная нотация (Big O Notation):** Описывает асимптотическое поведение алгоритма при стремлении размера входных
   данных к бесконечности. Наиболее распространенные обозначения:
    - O(1) - постоянное время. Временная сложность не зависит от размера входных данных.
    - O(log n) - логарифмическое время. Пример: бинарный поиск.
    - O(n) - линейное время. Пример: поиск элемента в несортированном массиве.
    - O(n log n) - линейное логарифмическое время. Пример: сортировка слиянием (Merge Sort).
    - O(n^2) - квадратичное время. Пример: сортировка пузырьком (Bubble Sort).
    - O(2^n) - экспоненциальное время. Пример: задачи коммивояжера.
    - O(n!) - факториальное время. Пример: перебор всех перестановок.

2. **Анализ в среднем (Average-Case Analysis):** Оценивает алгоритмы с учетом среднего входа, а не худшего случая. Это
   может быть полезно, если вы ожидаете, что алгоритм будет использоваться на входах, которые могут различаться.

Примеры оценки сложности алгоритмов:

1. **Бинарный поиск:** Оценка - O(log n). Этот алгоритм работает в логарифмическое время, так как на каждом шаге
   уменьшает область поиска вдвое.

2. **Линейный поиск:** Оценка - O(n). Алгоритм просматривает каждый элемент в худшем случае, что приводит к линейной
   сложности.

3. **Сортировка слиянием:** Оценка - O(n log n). Эффективный алгоритм сортировки, который разделяет и объединяет массив
   на каждом шаге.

4. **Сортировка пузырьком:** Оценка - O(n^2). Наихудший случай требует квадратичного числа операций.

5. **Алгоритм быстрого возведения в степень:** Оценка - O(log n). Этот алгоритм использует рекурсию и деление задачи
   пополам для быстрого возведения в степень.

Оценка сложности алгоритмов позволяет выбирать наиболее эффективный алгоритм для решения задачи в зависимости от размера
входных данных.